# VCA_Protocol_v2.1.yaml
# Generated: 2025-09-02T13:36:29.597074Z
# This is the canonical VCA ruleset (v2.1): hierarchical Entities→Charts→Events, inlined schemas,
# unified gating, QuickScan preflight, AP SUPER orchestration, intake wizard, optional anonymization.

# ASTROLOGY_MANIFEST_v2.1.yaml
# Generated: 2025-09-02T13:28:23.532468Z
# This manifest inlines schemas and small registries, so you can delete external template CSVs.

schemas:
  ENTITIES:
    required: [entity_id, entity_kind, display_label, consent_level, active, created_at, updated_at]
    fields:
      entity_id:        {type: string, unique: true, format: slug_or_uuid}
      entity_kind:      {type: enum, values: [individual, composite, group, org, other]}
      display_label:    {type: string}
      public_alias:     {type: string, nullable: true}
      member_ids:       {type: list|string, sep: "|", nullable: true}
      consent_level:    {type: enum, values: [private, internal, shared, public], default: internal}
      active:           {type: bool,  default: true}
      tags:             {type: list|string, sep: "|", nullable: true}
      notes_private:    {type: text,  nullable: true}
      created_at:       {type: datetime}
      updated_at:       {type: datetime}
      source_file:      {type: string, nullable: true}
      # Optional diagnostics
      datasets_ok:      {type: bool, default: true, nullable: true}

  CHARTS:
    required: [chart_id, entity_id, chart_type, created_at, updated_at]
    fields:
      chart_id:         {type: string, unique: true, format: slug_or_uuid}
      entity_id:        {type: string, fk: "ENTITIES.entity_id"}
      chart_type:       {type: enum, values: [natal, draconic, harmonic, composite, midpoint, davison, group, solar_return, lunar_return, transit_context, coalescent, other]}
      reference_system: {type: enum, values: [tropical, sidereal, other], default: tropical}
      epoch:            {type: string, nullable: true, default: "J2000"}
      calc_notes:       {type: text, nullable: true}
      metadata:         {type: text, nullable: true}
      created_at:       {type: datetime}
      updated_at:       {type: datetime}
      source_file:      {type: string, nullable: true}

  EVENTS:
    required: [event_id, chart_id, event_dt_utc, event_tz, event_date_accuracy, title, event_type, visibility, created_at, updated_at]
    fields:
      event_id:         {type: string, unique: true, format: slug_or_uuid}
      chart_id:         {type: string, fk: "CHARTS.chart_id"}
      entity_id:        {type: string, fk: "ENTITIES.entity_id", nullable: true}
      event_dt_utc:     {type: datetime, tz: "UTC"}
      event_tz:         {type: tz}
      event_local_dt:   {type: datetime, nullable: true}
      event_date_accuracy: {type: enum, values: [exact, approx, range_start, range_end, unknown], default: exact}
      title:            {type: string}
      description:      {type: text, nullable: true}
      event_type:       {type: enum, values: [transit, progression, solar_arc, life_event, reading, ritual, upload, import, other]}
      subtype:          {type: string, nullable: true}
      module_origin:    {type: string, nullable: true}
      score_strength:   {type: float, range: [0,1], nullable: true}
      score_valence:    {type: float, range: [-1,1], nullable: true}
      orb_deg:          {type: float, nullable: true}
      aspect:           {type: string, nullable: true}
      bodies:           {type: list|string, sep: "|", nullable: true}
      location_context: {type: string, nullable: true}
      media_refs:       {type: list|string, sep: "|", nullable: true}
      tags:             {type: list|string, sep: "|", nullable: true}
      visibility:       {type: enum, values: [private, internal, shared, public], default: internal}
      created_at:       {type: datetime}
      updated_at:       {type: datetime}
      source_file:      {type: string, nullable: true}

embedded_tables:
  CHART_TYPES_registry:
    columns: [chart_type, description, active_default]
    rows:
      - [natal, "Individual birth chart (tropical default)", true]
      - [draconic, "Nodes-referenced draconic chart", true]
      - [harmonic, "Harmonic charts (H varies; set via metadata)", true]
      - [composite, "Standard composite midpoint", true]
      - [midpoint, "Explicit midpoint composite", true]
      - [davison, "Davison time-space midpoint", true]
      - [group, "Group composite (3+ members)", true]
      - [solar_return, "Solar Return chart", true]
      - [lunar_return, "Lunar Return chart", true]
      - [transit_context, "Transit-only context", true]
      - [coalescent, "Alt composite variant", false]
      - [other, "Custom/experimental", false]

  ENTITY_CHART_MATRIX:
    columns: [entity_id, entity_kind, display_label, member_ids,
              natal, draconic, harmonic, composite, midpoint, davison, group,
              solar_return, lunar_return, transit_context, coalescent, other, datasets_ok]
    rows:
      - ["__TEMPLATE__", "individual", "Example", "",
         true, true, true, false, false, false, false, true, true, true, false, false, true]

access:
  ap_super:
    sources: ["ENTITIES","CHARTS","EVENTS","embedded_tables.CHART_TYPES_registry","embedded_tables.ENTITY_CHART_MATRIX"]
    mode: "read_all"

gating:
  order: ["consent","activation","visibility","datasets_ok","matrix_scope"]
  rules:
    consent:
      ENTITIES: "consent_level in ['internal','shared','public']"
      EVENTS:   "visibility in ['internal','shared','public']"
    activation:
      ENTITIES: "active == true"
      CHARTS:   "true"
    visibility:
      EVENTS:   "visibility != 'private'"
    datasets_ok:
      ENTITIES: "entity_kind != 'individual' or datasets_ok != false"
      CHARTS:   "true"
    matrix_scope:
      CHARTS:   "embedded_tables.ENTITY_CHART_MATRIX[entity_id][chart_type] == true"

charts:
  source: embedded_tables.ENTITY_CHART_MATRIX
  require_datasets_ok: true
  create_charts_when:
    condition: "row[chart_type] == true"
    expand:
      chart_id: "chart_{entity_id}_{chart_type}"
      entity_id: "{entity_id}"
      chart_type: "{chart_type}"
      reference_system: "tropical"
      epoch: "J2000"

preflight:
  quickscan:
    enabled: true
    window_padding: {default: {days: 7}, monthly: {days: 15}}
    datasets:
      draconic:   {check: "compute_transit_hits", aspects: [conjunction, opposition, square, trine, sextile, quincunx], orb_deg: 1.0}
      harmonics:  {check: "compute_harmonic_hits", aspects: [conjunction, opposition, square, trine, sextile], orb_deg: 0.8, modes: {H: [1,2,3,4,5,6,7,8,9,10,11,12]}}
      progressions: {type: "secondary", check: "compute_progressed_hits", aspects: [conjunction, opposition, square, trine, sextile], orb_deg: 0.8}
      solar_arc:  {check: "compute_solar_arc_hits", aspects: [conjunction, opposition, square, trine, sextile], orb_deg: 0.5}
      returns:
        solar_return: {check: "compute_solar_return_exact", expand_if_within_days: 30}
        lunar_return: {check: "compute_lunar_return_exact", expand_if_within_days: 5}
    expand_rules: {any_hit_triggers_full_run: true, min_hits_to_expand: 1, min_quick_strength: 0.25}
    include_light_context_when_no_hits: true

runs:
  ap_super:
    inputs: {targets: ["*"], scope: "ALL_DATA"}
    preflight: {use: preflight.quickscan, window_mode: "monthly"}
    selection:
      entities: "gated(ENTITIES)"
      charts:   "gated(CHARTS) and entity_id in :entities.entity_id"
      events:   "gated(EVENTS) and chart_id in :charts.chart_id"
    export_profile: "internal"

intake:
  wizard:
    enabled: true
    expects:
      individuals_minimum: [display_label]
      events_minimum: [title, event_local_dt, event_tz]
    defaults:
      entities: {consent_level: internal, active: true}
      events: {event_type: life_event, event_date_accuracy: exact, visibility: internal, module_origin: INTAKE_WIZARD}
  data_index:
    enabled: true
    discover:
      sources:
        - type: file
          glob: ["*.csv"]
          include: ["*Entities*","*Event*","*Composite*","*Harmonic*","*Draconic*","*Natal*"]
    build_index:
      output: "INDIVIDUAL_DATA_INDEX_v1.0.csv"

privacy:
  anonymization:
    enabled: false
    require_explicit: true
    salt_file: "ANON_SALT.txt"
    id_field_internal: "entity_id"
    id_field_anon: "anon_id"

performance:
  tuning:
    event_partition: "monthly"
    event_indexes: ["chart_id","event_dt_utc"]

# --- Auto-Refresh Hook (added 2025-09-02) -------------------
hooks:
  pre_run:
    - name: refresh_sources
      handler: builtin.refresh_sources
      description: Auto-discover & import newest CSVs into ASTRO_ENGINE before any run.
      config:
        engine_db: /mnt/data/ASTRO_ENGINE.sqlite
        data_dir: /mnt/data
        # If true, also builds/refreshes helper views and indexes
        ensure_views_and_indexes: true
        # Optional: prewarm small transit caches for recent windows (tunable per mode)
        transit_cache:
          enabled: true
          windows:
            - { start: "2025-09-01T00:00:00Z", end: "2025-11-01T00:00:00Z" }
        # Patterns are already stored in engine_autodiscover, but you may shadow them here
        patterns_override: []

# --- Auto-Refresh Hook: Per-Mode Transit Cache Policy (added 2025-09-02) ---
hooks:
  pre_run:
    - name: refresh_sources
      handler: builtin.refresh_sources
      description: Auto-discover & import newest CSVs into ASTRO_ENGINE before any run.
      config:
        engine_db: /mnt/data/ASTRO_ENGINE.sqlite
        data_dir: /mnt/data
        ensure_views_and_indexes: true
        transit_cache:
          enabled: true
          per_mode:
            ap_super:
              kind: month         # cache current calendar month
              months_offset: 0
            daily:
              kind: days          # ±3 days window
              days_before: 3
              days_after: 3
            narrativity:
              kind: quarter       # current quarter
              quarters_offset: 0

# --- Pre-run: Fail-Fast & Cache Refresh (added 2025-09-02) ---
hooks:
  pre_run:
    - name: refresh_sources
      handler: builtin.refresh_sources
      description: Auto-discover & import newest CSVs into ASTRO_ENGINE before any run.
      config:
        engine_db: /mnt/data/ASTRO_ENGINE.sqlite
        data_dir: /mnt/data
        ensure_views_and_indexes: true
        # Keep caches around that are pinned in engine_pins
        respect_pins: true
        transit_cache:
          enabled: true
          per_mode:
            ap_super: { kind: month, months_offset: 0 }
            daily:    { kind: days,  days_before: 3, days_after: 3 }
            narrativity: { kind: quarter, quarters_offset: 0 }
    - name: fail_fast_if_errors
      handler: builtin.sql_check
      description: Abort run if engine_checks reports any issues.
      config:
        engine_db: /mnt/data/ASTRO_ENGINE.sqlite
        # SQL must return a single row with a column named total_errors
        check_sql: |
          SELECT total_errors FROM engine_failfast_summary
        abort_if:
          operator: '>'
          value: 0
        on_abort_message: |
          Data integrity checks failed. Please review `engine_checks` for details
          (e.g., missing IDs or orphaned references). Fix the source CSVs, then rerun.
    - name: pin_hot_paths
      handler: builtin.sql_exec
      description: Mark frequently used caches/views as recently used so retention keeps them.
      config:
        engine_db: /mnt/data/ASTRO_ENGINE.sqlite
        sql: |
          UPDATE engine_pins SET last_used_utc = CURRENT_TIMESTAMP
          WHERE name IN (
            'transit_cache_daily_20250830_20250906',
            'transit_cache_ap_super_20250901_20251001',
            'transit_cache_narrativity_Q3_20250701_20251001',
            'transits_current','transits_alias',
            'transits_daily_current','transits_month_current','transits_quarter_current'
          );

# --- Pin Policy: Larger windows for pinned + auto-demotion (added 2025-09-02) ---
hooks:
  pre_run:
    - name: apply_pin_demotions
      handler: builtin.sql_exec
      description: Auto-demote stale pins based on engine_pin_policy.demote_after_days
      config:
        engine_db: /mnt/data/ASTRO_ENGINE.sqlite
        sql: |
          UPDATE engine_pins
             SET priority = MIN(
                 COALESCE((SELECT max_priority FROM engine_pin_policy pol WHERE engine_pins.name LIKE pol.name_pattern), 999),
                 priority + 10
             )
           WHERE name IN (
             SELECT p.name
               FROM engine_pins p
               JOIN engine_pin_policy pol ON p.name LIKE pol.name_pattern
              WHERE p.last_used_utc IS NOT NULL
                AND (julianday('now') - julianday(p.last_used_utc)) > pol.demote_after_days
           );

    - name: refresh_sources
      handler: builtin.refresh_sources
      description: Auto-discover/import newest CSVs and warm caches; expand windows for pinned items
      config:
        engine_db: /mnt/data/ASTRO_ENGINE.sqlite
        data_dir: /mnt/data
        ensure_views_and_indexes: true
        respect_pins: true
        pin_window_expansion: true     # NEW: enlarge windows for pinned caches (uses engine_pin_policy.window_multiplier)
        transit_cache:
          enabled: true
          per_mode:
            ap_super:   { kind: month,   months_offset: 0 }
            daily:      { kind: days,    days_before: 3, days_after: 3 }
            narrativity:{ kind: quarter, quarters_offset: 0 }

    - name: pin_hot_paths
      handler: builtin.sql_exec
      description: Mark frequently used caches/views as recently used so retention keeps them.
      config:
        engine_db: /mnt/data/ASTRO_ENGINE.sqlite
        sql: |
          UPDATE engine_pins SET last_used_utc = CURRENT_TIMESTAMP
          WHERE name IN (
            'transit_cache_daily_20250830_20250906',
            'transit_cache_ap_super_20250901_20251001',
            'transit_cache_narrativity_Q3_20250701_20251001',
            'transits_current','transits_alias',
            'transits_daily_current','transits_month_current','transits_quarter_current'
          );

# --- Pin cap enforcement (added 2025-09-02) ---
hooks:
  pre_run:
    - name: enforce_pin_caps
      handler: builtin.sql_exec
      description: Unpin oldest/lowest-priority items beyond size caps; drop very old unpinned caches.
      config:
        engine_db: /mnt/data/ASTRO_ENGINE.sqlite
        sql: |
          -- Unpin all items over cap by size_class
          DELETE FROM engine_pins
           WHERE (kind, name) IN (
             SELECT kind, name FROM engine_pins_over_cap
           );

          -- Optional: drop very old, now-unpinned cache tables that match cache prefix and are not in pins
          -- Keep newest 3 per family even if unpinned
          WITH cache_tables AS (
            SELECT name FROM sqlite_master WHERE type='table' AND name LIKE 'transit_cache_%'
          ),
          keepers AS (
            SELECT name FROM engine_pins WHERE kind='cache'
            UNION ALL
            SELECT name FROM (
              SELECT name FROM cache_tables WHERE name LIKE 'transit_cache_daily_%' ORDER BY name DESC LIMIT 3
            )
            UNION ALL
            SELECT name FROM (
              SELECT name FROM cache_tables WHERE name LIKE 'transit_cache_ap_super_%' ORDER BY name DESC LIMIT 3
            )
            UNION ALL
            SELECT name FROM (
              SELECT name FROM cache_tables WHERE name LIKE 'transit_cache_narrativity_%' ORDER BY name DESC LIMIT 3
            )
          )
          SELECT 1;  -- placeholder; actual dropping is handled inside engine code if supported

# --- Date-range classification (added 2025-09-02) ---
hooks:
  pre_run:
    - name: classify_cache_by_daterange
      handler: builtin.sql_exec
      description: Parse transit_cache_* table names, compute span, set size_class (small/medium/large) based on days.
      config:
        engine_db: /mnt/data/ASTRO_ENGINE.sqlite
        sql: |
          -- Rebuild cache meta from table names
          DELETE FROM engine_cache_meta;
          WITH caches AS (
            SELECT name AS cache_name FROM sqlite_master WHERE type='table' AND name LIKE 'transit_cache_%'
          )
          INSERT INTO engine_cache_meta(cache_name,start_date,end_date,span_days)
          SELECT cache_name,
                 substr(cache_name, instr(cache_name, '_', instr(cache_name, '_', instr(cache_name, '_')+1)+1)+1, 8) AS start_yyyymmdd,
                 substr(cache_name, length(cache_name)-7, 8) AS end_yyyymmdd,
                 CAST( (julianday(substr(cache_name, length(cache_name)-7, 8)) - julianday(substr(cache_name, instr(cache_name, '_', instr(cache_name, '_', instr(cache_name, '_')+1)+1)+1, 8))) AS INTEGER ) AS span_days
          FROM caches;

          -- Update pin sizes based on thresholds
          UPDATE engine_pins
             SET size_class = (
               SELECT CASE 
                        WHEN span_days <= (SELECT small_max_days FROM engine_cache_size_thresholds) THEN 'small'
                        WHEN span_days <= (SELECT medium_max_days FROM engine_cache_size_thresholds) THEN 'medium'
                        ELSE 'large'
                      END
                 FROM engine_cache_meta m WHERE m.cache_name = engine_pins.name
             )
           WHERE kind='cache' AND name IN (SELECT cache_name FROM engine_cache_meta);

# --- Cache size caps (added 2025-09-02) ---
hooks:
  pre_run:
    - name: enforce_cache_size_caps
      handler: builtin.sql_exec
      description: Ensure total cache sizes stay under caps by evicting oldest non-pinned caches first.
      config:
        engine_db: /mnt/data/ASTRO_ENGINE.sqlite
        sql: |
          -- Build working sets
          WITH sizes AS (
            SELECT s.table_name, s.size_bytes, c.size_class
            FROM engine_cache_sizes s
            LEFT JOIN engine_cache_size_class c ON c.cache_name = s.table_name
          ),
          pinned AS (SELECT name FROM engine_pins WHERE kind='cache')
          SELECT 1;

          -- Eviction logic is performed by the engine runtime using this metadata:
          -- 1) If total_bytes > global cap, drop oldest non-pinned caches across all classes until under cap.
          -- 2) If class_bytes > class cap (small/medium/large), drop oldest non-pinned caches in that class until under cap.
          -- Oldest is approximated by table name (ISO-ish date suffix) and least recently used (last_used_utc).

# --- Lightweight Hits + Nightly Maintenance (added 2025-09-02) ---
hooks:
  pre_run:
    - name: materialize_ap_super_hits
      handler: builtin.sql_exec
      description: Build lightweight AP Super hits for the current cache using engine_hit_rules.
      config:
        engine_db: /mnt/data/ASTRO_ENGINE.sqlite
        sql: |
          DELETE FROM ap_super_hits_current;
          INSERT INTO ap_super_hits_current(dt_utc, chart_id, body, aspect_deg, diff_deg, orb_deg, transit_long, chart_long)
          SELECT dt_utc, chart_id, body, aspect_deg, diff_deg, orb_deg, transit_long, chart_long
          FROM (
            SELECT * FROM ap_super_hits_current -- placeholder if prebuilt; no-op
          );

    - name: nightly_maintenance
      handler: builtin.sql_exec
      description: Run heavy maintenance only at night when user is inactive.
      config:
        engine_db: /mnt/data/ASTRO_ENGINE.sqlite
        sql: |
          -- Check flag
          WITH f AS (SELECT should_run FROM engine_nightly_should_run)
          SELECT CASE WHEN (SELECT should_run FROM f)=1 THEN 1 ELSE 0 END AS ok;

          -- Heavy ops are executed by runtime when ok=1 (VACUUM, REINDEX, cache rebuilds)
          -- This keeps daytime runs snappy and defers heavier work safely.
