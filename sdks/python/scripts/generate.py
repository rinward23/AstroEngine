"""Generate the astro-sdk package from a versioned OpenAPI document."""
from __future__ import annotations

import argparse
import datetime as dt
import hashlib
import json
from pathlib import Path
from typing import Any, Dict, List

SCRIPT_DIR = Path(__file__).resolve().parent
PROJECT_ROOT = SCRIPT_DIR.parent
REPO_ROOT = PROJECT_ROOT.parent.parent
DEFAULT_SCHEMA = REPO_ROOT / "openapi" / "v1.0.json"
GENERATED_PATH = PROJECT_ROOT / "astro_sdk" / "generated" / "schema.py"
CHANGELOG_PATH = PROJECT_ROOT / "CHANGELOG.md"

DATASETS = {
    "solarfire": Path("datasets/solarfire/README.md"),
    "swiss_ephemeris": Path("datasets/swisseph_stub/README.md"),
}


def sha256(data: bytes) -> str:
    return hashlib.sha256(data).hexdigest()


def dataset_digest(relative: Path) -> str:
    target = (REPO_ROOT / relative).resolve()
    if not target.exists():
        return f"missing:{relative.as_posix()}"
    return sha256(target.read_bytes())[:16]


def load_schema(path: Path) -> Dict[str, Any]:
    return json.loads(path.read_text())


def build_operations(schema: Dict[str, Any]) -> List[Dict[str, str]]:
    operations: List[Dict[str, str]] = []
    for path_name, methods in (schema.get("paths") or {}).items():
        for method, spec in methods.items():
            operations.append(
                {
                    "method": method.upper(),
                    "path": path_name,
                    "operationId": spec.get("operationId")
                    or f"{method}_{path_name}".replace("/", "_"),
                    "summary": spec.get("summary") or spec.get("description") or "",
                }
            )
    return operations


def write_generated(metadata: Dict[str, Any], operations: List[Dict[str, str]]) -> None:
    GENERATED_PATH.parent.mkdir(parents=True, exist_ok=True)
    content = (
        '"""Auto-generated by scripts/generate.py; do not edit manually."""\n'
        "from __future__ import annotations\n\n"
        f'SCHEMA_VERSION = "{metadata["schema_version"]}"\n'
        f'SCHEMA_PATH = "{metadata["schema_path"]}"\n'
        f'SCHEMA_HASH = "{metadata["schema_hash"]}"\n\n'
        f"OPERATIONS = {operations!r}\n"
        f"RELEASE_METADATA = {metadata!r}\n"
    )
    GENERATED_PATH.write_text(content)


def update_changelog(metadata: Dict[str, Any]) -> None:
    if CHANGELOG_PATH.exists():
        existing = CHANGELOG_PATH.read_text()
    else:
        existing = "# astro-sdk changelog\n\n"

    if metadata["schema_hash"] in existing:
        return

    today = dt.date.today().isoformat()
    lines = [
        f"## Schema {metadata['schema_version']} â€” {today}",
        f"- Schema: {metadata['schema_path']} (sha256: {metadata['schema_hash']})",
        f"- Solar Fire dataset fingerprint: {metadata['datasets']['solarfire']}",
        f"- Swiss Ephemeris dataset fingerprint: {metadata['datasets']['swiss_ephemeris']}",
        "",
    ]
    if not existing.endswith("\n\n"):
        existing += "\n"
    CHANGELOG_PATH.write_text(existing + "".join(line + "\n" for line in lines))


def generate(schema_path: Path) -> Dict[str, Any]:
    schema = load_schema(schema_path)
    raw = json.dumps(schema, sort_keys=True).encode()
    schema_hash = sha256(raw)
    operations = build_operations(schema)
    metadata = {
        "schema_path": schema_path.relative_to(REPO_ROOT).as_posix(),
        "schema_version": schema.get("info", {}).get("version", "0.0.0"),
        "schema_hash": schema_hash,
        "datasets": {key: dataset_digest(path) for key, path in DATASETS.items()},
    }
    write_generated(metadata, operations)
    update_changelog(metadata)
    return metadata


def main() -> None:
    parser = argparse.ArgumentParser(description="Generate astro-sdk artefacts from an OpenAPI schema")
    parser.add_argument("--schema", type=Path, default=DEFAULT_SCHEMA, help="Path to the OpenAPI schema")
    args = parser.parse_args()
    metadata = generate(args.schema.resolve())
    print(
        f"Generated astro-sdk for {metadata['schema_version']} (schema {metadata['schema_hash'][:12]})",
        flush=True,
    )


if __name__ == "__main__":
    main()
